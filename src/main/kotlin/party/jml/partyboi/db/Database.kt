package party.jml.partyboi.db

import arrow.core.*
import arrow.core.raise.either
import com.zaxxer.hikari.HikariDataSource
import io.ktor.server.application.*
import kotlinx.datetime.Instant
import kotlinx.datetime.toJavaInstant
import kotlinx.datetime.toJavaLocalDateTime
import kotliquery.*
import kotliquery.action.*
import party.jml.partyboi.Logging
import party.jml.partyboi.config
import party.jml.partyboi.data.DatabaseError
import party.jml.partyboi.data.NotFound
import party.jml.partyboi.system.AppResult
import java.nio.file.Path
import java.sql.Timestamp

class DatabasePool(val dataSource: HikariDataSource) : Logging() {
    suspend fun <A> use(tx: TransactionalSession? = null, block: suspend (Session) -> A): A =
        if (tx != null) {
            block(tx)
        } else {
            sessionOf(dataSource).use { block(it) }
        }

    suspend fun <A> transaction(
        schema: String? = null,
        block: suspend (TransactionalSession) -> AppResult<A>
    ): AppResult<A> =
        sessionOf(dataSource).use { it.transactionEither(schema) { tx -> block(tx) } }

    suspend fun <A> useUnsafe(block: suspend (Session) -> A): A =
        sessionOf(dataSource).use { block(it) }

    suspend fun createSchema(name: String): AppResult<String> {
        val schema = transaction {
            dropSchema(it, name)
            it.exec(queryOf("CREATE SCHEMA $name"))
        }
        val self = this
        return either {
            schema.bind()
            Migrations.migrate(self, name).bind()
            name
        }
    }

    private fun dropSchema(tx: TransactionalSession, name: String) =
        tx.exec(queryOf("DROP SCHEMA IF EXISTS $name CASCADE"))

    @SuppressWarnings
    fun debugPrintPoolState(message: String) {
        val pool = dataSource.hikariPoolMXBean
        log.info("$message: ${dataSource.poolName} (total=${pool.totalConnections}, active=${pool.activeConnections}, idle=${pool.idleConnections}, waiting=${pool.threadsAwaitingConnection})")
    }

}

fun Session.runSafely(query: ExecuteQueryAction): AppResult<Boolean> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it) }

fun Session.runSafely(query: UpdateQueryAction): AppResult<Int> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it) }

fun Session.runSafely(query: UpdateAndReturnGeneratedKeyQueryAction): AppResult<Option<Long>> =
    Either.catch { run(query).toOption() }.mapLeft { DatabaseError(it) }

fun <A> Session.runSafely(query: ListResultQueryAction<A>): AppResult<List<A>> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it) }

fun <A> Session.runSafely(query: NullableResultQueryAction<A>): AppResult<Option<A>> =
    Either.catch { run(query).toOption() }.mapLeft { DatabaseError(it) }

fun <A> Session.option(query: ResultQueryActionBuilder<A>): AppResult<Option<A>> =
    runSafely(query.asSingle)

fun <A> Session.one(query: ResultQueryActionBuilder<A>): AppResult<A> =
    option(query).flatMap { it.toEither { NotFound("Not found") } }

fun <A> Session.many(query: ResultQueryActionBuilder<A>): AppResult<List<A>> =
    runSafely(query.asList)

fun <A> Session.atLeastOne(query: ResultQueryActionBuilder<A>): AppResult<NonEmptyList<A>> =
    many(query).flatMap { it.toNonEmptyListOrNone().toEither { NotFound("Not found") } }

fun Session.exec(query: Query): AppResult<Unit> =
    runSafely(query.asExecute).map {}

fun Session.updateAny(query: Query): AppResult<Int> =
    runSafely(query.asUpdate)

fun Session.updateOne(query: Query): AppResult<Unit> =
    updateAny(query).flatMap { if (it != 1) NotFound("Not found").left() else Unit.right() }

object DbBasicMappers {
    val asString: (Row) -> String = { it.string(1) }
    val asOptionalString: (Row) -> String? = { it.stringOrNull(1) }
    val asBoolean: (Row) -> Boolean = { it.boolean(1) }
    val asInt: (Row) -> Int = { it.int(1) }
    val asIntOrNull: (Row) -> Int? = { it.intOrNull(1) }
}

inline fun <A> Session.transactionEither(
    schema: String?,
    operation: (TransactionalSession) -> AppResult<A>
): AppResult<A> {
    try {
        connection.begin()
        transactional = true
        val tx = TransactionalSession(connection, returnGeneratedKeys, autoGeneratedKeys, strict)
        if (schema != null) {
            tx.exec(queryOf("SET search_path TO $schema"))
        }
        val result = operation.invoke(tx)
        if (result.isRight()) {
            connection.commit()
        } else {
            connection.rollback()
        }
        return result
    } catch (e: Exception) {
        connection.rollback()
        throw e
    } finally {
        transactional = false
        if (schema != null) {
            exec(queryOf("SET search_path TO public"))
        }
    }
}

fun queryOf(statement: String, vararg params: Any?): Query {
    return Query(statement, params = params.toList().map { convertQueryParam(it) })
}

fun convertQueryParam(param: Any?): Any? = when (param) {
    is Option<*> -> param.getOrNull()
    is kotlinx.datetime.LocalDateTime -> Timestamp.valueOf(param.toJavaLocalDateTime())
    is Instant -> Timestamp.from(param.toJavaInstant())
    is Path -> param.toString()
    is Enum<*> -> param.name
    is List<*> -> throw RuntimeException("Pass a typed array instead of List to a query")
    else -> param
}

fun Application.getDatabasePool(): DatabasePool {
    Class.forName("org.postgresql.Driver")
    val cfg = config()
    val url = "jdbc:postgresql://${cfg.dbHost}:${cfg.dbPort}/${cfg.dbDatabase}"
    return DatabasePool(HikariCP.default(url, cfg.dbUser, cfg.dbPassword))
}
